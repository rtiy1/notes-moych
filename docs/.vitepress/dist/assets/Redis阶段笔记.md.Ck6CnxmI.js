import{_ as d,c as t,o as a,ae as o}from"./chunks/framework.CDjunVez.js";const _=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Redis阶段笔记.md","filePath":"Redis阶段笔记.md"}'),r={name:"Redis阶段笔记.md"};function c(i,e,s,n,h,p){return a(),t("div",null,[...e[0]||(e[0]=[o('<h2 id="redis阶段" tabindex="-1">Redis阶段： <a class="header-anchor" href="#redis阶段" aria-label="Permalink to &quot;Redis阶段：&quot;">​</a></h2><h3 id="事务和锁机制" tabindex="-1">事务和锁机制： <a class="header-anchor" href="#事务和锁机制" aria-label="Permalink to &quot;事务和锁机制：&quot;">​</a></h3><hr><h4 id="_1、redis事务的控制方式" tabindex="-1">1、Redis事务的控制方式： <a class="header-anchor" href="#_1、redis事务的控制方式" aria-label="Permalink to &quot;1、Redis事务的控制方式：&quot;">​</a></h4><p>事务为单线程核心执行的，事务执行的操作命令一般有</p><table tabindex="0"><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>multi</td><td>宣告开始把命令加入队列</td></tr><tr><td>discard</td><td>对于已经加入队列的命令，放弃执行</td></tr><tr><td>exec</td><td>执行队列中的每一条命令</td></tr><tr><td>watch</td><td>在 <code>MULTI</code> 之前使用，用于乐观锁机制：监视一个或多个 key。如果在 <code>EXEC</code> 执行前这些 key 被其他客户端修改，则整个事务会被取消（<code>EXEC</code> 返回 <code>nil</code>）。</td></tr></tbody></table><p>Redis事务具有原子性的特点，但是在发生<code>运行时错误</code>的时候，继续执行。</p><p>语法错误（入队时报错）：如命令不存在、参数错误等，在 <code>EXEC</code> 时整个事务会被拒绝执行。</p><p>运行时错误（执行时报错）：如对错误的数据类型操作，该命令失败但其余命令继续执行。</p><p>Redis事务不支持回滚。</p><h4 id="_2、乐观锁和悲观锁" tabindex="-1">2、乐观锁和悲观锁： <a class="header-anchor" href="#_2、乐观锁和悲观锁" aria-label="Permalink to &quot;2、乐观锁和悲观锁：&quot;">​</a></h4><p>悲观锁：写操作占比高，并发写的几率高，用同步锁保护自身操作，自己进行操作时，不允许其他线程执行。</p><p><strong>乐观锁</strong>：读操作占比高，碰撞几率低，不锁定数据，充分保证并发操作同时执行。如果在自己进行写操作时，其他线程操作修改了数据，则自己（本线程）会放弃自身操作。</p><h2 id="rdb和aof" tabindex="-1">RDB和AOF： <a class="header-anchor" href="#rdb和aof" aria-label="Permalink to &quot;RDB和AOF：&quot;">​</a></h2><p>RDB持久化：</p><p>RDB 持久化通过 <code>BGSAVE</code> 实现：主进程 <code>fork</code> 出子进程，子进程基于 COW 机制读取 fork 时刻的内存快照并写入 <code>.rdb</code> 文件。主进程继续服务，无阻塞。RDB 是全量快照，适合备份和快速恢复，但可能丢失最后一次快照后的数据。</p><p>AOF持久化：</p><p>需要手动在配置文件里面将AOF配置设置为yes，这样在操作过程中所使用的每一条命令都会记录在当前目录的.aof文件中，方便在服务器宕机时直接调用AOF的命令重建内存数据集。AOF里有三种持久化频率，第一种为<code>always</code>，指的是每次写入都进行持久化，第二种为<code>everysec</code>，指的是每一秒进行一次AOF持久化，第三种为<code>no</code>，由操作系统决定何时同步。一般来说，第二种选择比较好。</p><p>AOF 重写不是合并重复命令，而是基于当前内存状态生成最简重建命令，从而压缩 AOF 文件体积（磁盘空间）。通过 <code>BGREWRITEAOF</code> 触发，利用 fork + COW 机制实现在线无阻塞重写，确保数据一致性。</p>',19)])])}const f=d(r,[["render",c]]);export{_ as __pageData,f as default};
