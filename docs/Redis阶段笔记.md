## Redis阶段：

### 事务和锁机制：

------

#### 1、Redis事务的控制方式：

事务为单线程核心执行的，事务执行的操作命令一般有

| 命令名称 | 作用                                                         |
| -------- | ------------------------------------------------------------ |
| multi    | 宣告开始把命令加入队列                                       |
| discard  | 对于已经加入队列的命令，放弃执行                             |
| exec     | 执行队列中的每一条命令                                       |
| watch    | 在 `MULTI` 之前使用，用于乐观锁机制：监视一个或多个 key。如果在 `EXEC` 执行前这些 key 被其他客户端修改，则整个事务会被取消（`EXEC` 返回 `nil`）。 |

Redis事务具有原子性的特点，但是在发生`运行时错误`的时候，继续执行。

语法错误（入队时报错）：如命令不存在、参数错误等，在 `EXEC` 时整个事务会被拒绝执行。

运行时错误（执行时报错）：如对错误的数据类型操作，该命令失败但其余命令继续执行。

Redis事务不支持回滚。

#### 2、乐观锁和悲观锁：

悲观锁：写操作占比高，并发写的几率高，用同步锁保护自身操作，自己进行操作时，不允许其他线程执行。

**乐观锁**：读操作占比高，碰撞几率低，不锁定数据，充分保证并发操作同时执行。如果在自己进行写操作时，其他线程操作修改了数据，则自己（本线程）会放弃自身操作。

## RDB和AOF：

RDB持久化：

RDB 持久化通过 `BGSAVE` 实现：主进程 `fork` 出子进程，子进程基于 COW 机制读取 fork 时刻的内存快照并写入 `.rdb` 文件。主进程继续服务，无阻塞。RDB 是全量快照，适合备份和快速恢复，但可能丢失最后一次快照后的数据。

AOF持久化：

需要手动在配置文件里面将AOF配置设置为yes，这样在操作过程中所使用的每一条命令都会记录在当前目录的.aof文件中，方便在服务器宕机时直接调用AOF的命令重建内存数据集。AOF里有三种持久化频率，第一种为`always`，指的是每次写入都进行持久化，第二种为`everysec`，指的是每一秒进行一次AOF持久化，第三种为`no`，由操作系统决定何时同步。一般来说，第二种选择比较好。

AOF 重写不是合并重复命令，而是基于当前内存状态生成最简重建命令，从而压缩 AOF 文件体积（磁盘空间）。通过 `BGREWRITEAOF` 触发，利用 fork + COW 机制实现在线无阻塞重写，确保数据一致性。

